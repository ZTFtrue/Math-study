# MATH

## 向量

### 平面向量

### 空间向量

## 极坐标系

## 整数整除

### 同余与同余方程

#### 同余

数学上，同余（英语：congruence modulo，符号：≡）是数论中的一种等价关系。当两个整数除以同一个正整数，若得相同余数，则二整数同余。同余是抽象代数中的同余关系的原型。最先引用同余的概念与“≡”符号者为德国数学家高斯。

两个整数a，b，若它们除以正整数 m 所得的余数相等，则称a，b对于模 m 同余

记作${ a\equiv b{\pmod {m}}}$

读作a同余于b模m，或读作a与b关于模m同余。

比如${ 26\equiv 14{\pmod {12}}}$。

同余于的符号是同余相等符号≡。

#### 同余类

$a$的等价类是一个集合$\left\{\ldots ,a-2n,a-n,a,a+n,a+2n,\ldots \right\}$，标记为${\overline {a}}_{n}$。由对于模n同余的所有整数组成的这个集合称为同余类$[a]$。
同余类中的每个元素都可以拿来代表该同余类，称为该同余类的代表数（representative）
余数系统
余数系统（residue system）亦即模n同余类的代表数的集合，通常使用的代表数是最小非负整数，因为它是除法中的应当余数。要注意的是，对于同一个模数n，不同的_同余类_不等价，亦即，属于不同同余类的整数不同余于模数n，或者说，模n余数系统中的任二元素不同余于模n；而且，整数域中的_每个整数_只属于_模数n_的一个同余类，因为模n将整数域划分为互斥区块，每个区块是一个同余类。

一个完整余数系统（complete residue system）指的是模n的全部同余类的代表数的集合；因为余数系统中的任二元素不同余于模n，所以它也称为非同余余数的完整系统（英语：complete system of incongruent residues）。例如，模3有三个同余类$[0],[1],[2]$，其完整余数系统可以是${9,12+1,15+2}$。如果该集合是由每个同余类的最小非负整数所组成，亦即${0,1,2,...,n-1}$，则称该集合为模n的最小余数系统（least residue system）。

模n完整余数系统中，与模n互质的代表数所构成的集合，称为模n的简约余数系统（reduced residue system），其元素个数记为$\phi (n)$，亦即欧拉函数。例如，模$6$的简约余数系统为${1,5}(1,5 与6 互为质数)$或${7,11}$。如果模n是质数，那么它的最小简约余数系统是{1,2,...,n-1}$，只比最小余数系统少一个0。

同余性质

### 整除性

${\displaystyle a\equiv b{\pmod {m}}\Rightarrow c\cdot m=a-b,c\in \mathbb {Z} }$ （即是说 a 和 b 之差是 m 的倍数）,换句话说，${\displaystyle a\equiv b{\pmod {m}}\Rightarrow m\mid (a-b)}$  注:($ m\mid x $表示 m 能整除 x，或者说 x 能被 m 整除)
    同余可以用来检验一个数是否可以整除另外一个数.
        传递性
     $\left.\begin{matrix}a\equiv b(\mod m)\\ b\equiv c(\mod m) \end{matrix}\right\} \Rightarrow a\equiv c(\mod m)$
        保持基本运算
      $${\displaystyle \left.\begin{matrix}a\equiv b(\mod m)\\ c\equiv d(\mod m) \end{matrix}\right\} \Rightarrow\left\{ \begin{matrix}a\pm c\equiv b\pm d(\mod m)\\ ac\equiv bd(\mod m) \end{matrix}\right.}$$
     这性质更可进一步引申成为这样：$${\displaystyle {\displaystyle a\equiv b(\mod m)\Rightarrow\begin{cases} an\equiv bn(\mod m),\forall n\in\mathbb{Z}\\ a^{n}\equiv b^{n}(\mod m),\forall n\in\mathbb{N}^{0} \end{cases}}}$$
    时间计算
    计算机反码
    HASH 取模算法
    hash(对象) % N，结果必定小于N。
    如果我们有5个位置放这些对象，给每个位置编号0、1、2、3、4。使用HASH对象后的结果对5求余，那么余数一定是0、1、2、3、4，如果求余的结果为0， 我们就把当前对象放在在0号位置；如果余数为1，则放在1号位置；以此类推，能够直接判断出对象为于个位置上
      一致性HASH
    模运算
    参考自 应用密码学 协议算法与C源程序
    如果$a=b+kn$对某些整数$k$ 成立，那么$a\equiv b(mod n)$. 如果$a$为正,则b为$0~n$,那么你可以将b看作a被n整除以后的余数. 有时a叫做与 b 模 n 同余(congrunet)(三元等号$\equiv$ 表示同余).
    从$0~n$的整数组成的集合构成了模$n$的完全剩余集. 这意味着,对于每一个整数a,它的模n的余项是从$0~n-1$的某个数.
    a模n的运算给出了a的余数,余数是从$0~n-1$ 的某个整数,这种运算称为模变换(modular reduction). 例如,$5 mod 3 = 2$.
    (应用密码学 协议算法与C源程序 P171)  这里模的定义与一些编程语言中的模定义或许有些不同. 例如,PASCAL的模操作符有时返回一个负数. 它返回一个从$-(n-1)~n-1$的数.在C语言中,$%$操作符返回第一个表示项被第二个表示项相除所得的余数,如果其中一个操作项是负的,那么结果就为负. 对于本书的所有算法,如果它返回一个负数,你应该将n加到这个模运算操作的结果上.
      模运算的四则运算
    $$ (a+b) mod n= ((a mod n)+(b mod n)) mod n $$ 
    $$ (a-b) mod n= ((a mod n)-(b mod n)) mod n $$ 
    $$ (a\timesb) mod n= ((a mod n)\times(b mod n)) mod n $$ 
    $$ (a \times (b+c)) mod n= (((a \times b) mod n)+((a \times c) mod n)) mod n $$ 
    求模逆元
    向上取整
  二面角
  统计简介
    抽样方法
    总体分布的估计
    正态分布
    回归分析
      线性回归（svm机器学习）
    独立性检验
    优选法
    单峰函数
    黄金分割法
    分数发
    多因素法
    计验设计初步
  概率论
    [维基](https://zh.m.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA)
    事件
      单位事件
      在一次随机试验中可能发生的不能再细分的结果被称为基本事件，或者称为单位事件，用E表示。
      事件空间
      在随机试验中可能发生的所有单位事件的集合称为事件空间，用S来表示。
      随机事件
      随机事件是事件空间 {\displaystyle S}S 的子集，它由事件空间 {\displaystyle S}S 中的单位元素构成，用大写字母 {\displaystyle A,B,C\cdots }A,B,C\cdots  表示。例如在掷两个骰子的随机试验中，设随机事件 {\displaystyle A}A = “获得的点数和大于10”，则 {\displaystyle A}A 可以由下面 3 个单位事件组成：{\displaystyle A=\{(5,6),(6,5),(6,6)\}}A=\{(5,6),(6,5),(6,6)\}。
      必然事件 
      $ S\subset S $
      不可能事件
      $\varnothing \subset S $
      事件的计算
    概率的定义
      传统古典型概率
      传统概率的定义是由法国数学家拉普拉斯 ( Laplace ) 提出的。如果一个随机试验所包含的单位事件是有限的，且每个单位事件发生的可能性均相等，则这个随机试验叫做拉普拉斯试验。在拉普拉斯试验中，事件 A 在事件空间 S 中的概率 P(A) 为：$$P(A)=\frac{\text{构\text{成事件A的元素数目}}}{\text{构\text{成事件空间S的所有元素数目}}}$$
      例如，在一次同时掷一个硬币和一个骰子的随机试验中，假设事件 {\displaystyle A}A 为获得国徽面且点数大于 4 ，那么事件 A 的概率应该有如下计算方法：S= { ( 国徽，1 点 )，( 数字，1 点 )，( 国徽，2 点 )，( 数字，2 点 )，( 国徽，3 点 )，( 数字，3 点 )，( 国徽，4 点 )，( 数字，4 点 )，( 国徽，5 点 )，( 数字，5 点 )，( 国徽，6 点 )，( 数字，6 点 ) }，{\displaystyle A}A＝{( 国徽，5 点 )，( 国徽，6 点 )}，按照拉普拉斯定义，A 的概率为，$$P(A)={\frac {2}{12}}={\frac {1}{6}}$$
      注意到在拉普拉斯试验中存在着若干的疑问，在现实中是否存在着其单位事件的概率具有精确相同的概率值的试验? 因为我们不知道，硬币以及骰子是否完美，即骰子制造的是否均匀，其重心是否位于正中心，以及轮盘是否倾向于某一个数字。 尽管如此，传统概率在实践中被广泛应用于确定事件的概率值，其理论根据是： 如果没有足够的论据来证明一个事件的概率大于另一个事件的概率，那么可以认为这两个事件的概率值相等。
      如果仔细观察这个定义会发现拉普拉斯用概率解释了概率，定义中用了相同的可能性 ( 原文是 également possible )一词，其实指的就是"相同的概率"。这个定义也并没有说出，到底什么是概率，以及如何用数字来确定概率。在现实生活中也有一系列问题，无论如何不能用传统概率定义来解释，比如，人寿保险公司无法确定一个 50 岁的人在下一年将死去的概率。
      统计概率
      继传统概率论之后，英国逻辑学家约翰·维恩和奥地利数学家理查德提出建立在频率理论基础上的统计概率。他们认为，获得一个事件的概率值的唯一方法是通过对该事件进行 100 次，1000 次或者甚至 10000 次的前后相互独立的 $n$ 次随机试验，针对每次试验均记录下绝对频率值$h_{n}(A)$和相对频率值 $f_{n}(A)$，随着试验次数 $n$ 的增加，会出现如下事实，即相对频率值会趋于稳定，它在一个特定的值上下浮动，也即是说存在着一个极限值 $P(A)$，相对频率值趋向于这个极限值。这个极限值被称为统计概率，表示为：$$P(A)=\lim _{n\to \infty }f_{n}(A)$$
      例如，若想知道在一次掷骰子的随机试验中获得 6 点的概率值可以对其进行 3000 次前后独立的扔掷试验，在每一次试验后记录下出现 6 点的次数，然后通过计算相对频率值可以得到趋向于某一个数的统计概率值。
      大数定律
      https://zh.m.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B
      现代概率论	
      与初等概率论相对的，是“现代概率论”。因“测度论”的研究与发展，现代概率论得以建立公理化系统。一些曾经无法用初等概率论解释的概念因此得以用公理化的语言进行解释，可以说现代概率论以测度论为理论基础终于得以完善，完成了其现代化进程。现代概率论由前苏联数学家柯尔莫哥洛夫于1933年建立公理化。
    概率公理
    如果一个函数$P:S\to \mathbb {R} ,\ A\mapsto P(A)$指定给每一个事件空间$S$中的事件$A$一个实数$P(A)$，并且其满足下面的 3 个公理，那么函数$P$叫做概率函数，相应的$P(A)$ 叫做事件$A$的概率。
    公理 1： $0\leq P(A)\leq 1\ (A\in S)$,事件$A$ 的概率$P(A)$是一个0与1之间（包含0与1）的非负实数。
    公理 2：  P(S)=1,则事件空间的概率值为 1 。
    公理 3： $P(A\cup B)=P(A)+P(B)$，如果 $A\cap B=\varnothing$, 互斥事件的加法法则。这里需注意：公理3可以推广到可数个互斥事件的并集。
    概率的计算
    定理一(互补法则)
    与 $A$ 互补事件的概率始终是$$P({\bar {A}})=1-P(A),\in S$$
    证明：
    事件 $A$ 和 ${\overline {A}}$ 是互补关系，由公理 3 和公理 2 可得$$P(A)+P({\bar {A}})=P(S)=1 \Rightarrow P({\bar {A}})=1-P(A)$$
    利用互补法则，可以解决下面这个问题，在两次连续旋转的轮盘游戏中，至少有一次是红色的概率是多少？
    第一次旋转红色不出现的概率是 19/37 ，按照乘法法则，第二次也不出现红色的概率是 (19/37)2 = 0.2637，因此在这里互补概率就是指在两次连续旋转中至少有一次是红色的概率，$$P=1-\left({\frac {19}{37}}\right)^{2}=0.7363$$
    定理 2	
    不可能事件的概率为零：$$P(\varnothing )=0$$
    证明：
    $\varnothing#  和 $S$ 是互补事件，按照公理 2 有
    $P(S)=1$，再根据上面的定理 1 得到
    $P(\varnothing )=1-1=0$
    定理 3	
    如果若干事件$A_{1},A_{2},\cdots A_{n}\in S$ 每两两之间是空集关系，那么这些所有事件集合的概率等于单个事件的概率的和。$$P(A_{1}\cup \cdots \cup A_{n})=\sum _{j=1}^{n}P(A_{j})$$
    注意针对这一定理有效性的决定因素是$A_{1}\cdots A_{n}$事件不能同时发生。例如，在一次掷骰子中，得到 5 点或者 6 点的概率是：$$P=P(A_{5})+P(A_{6})=\frac{|\{1+1\}|}{\text{|\{总\text{共6个事件\}|}}}={\frac{2}{6}}={\frac{1}{3}}$$
    定理 4	
    如果事件$A$，$B$ 是差集关系，则有，$$P(A\setminus B)=P(A)-P(A\cap B)$$
    证明：
    事件A 由下面两个事件组成：
    $A\setminus B$ 和 $A\cap B$
    由公理 3 得，
    $P(A)=P(A\setminus B)+P(A\cap B)$
    定理 5 (任意事件加法法则)	
    对于事件空间$$S$$中的任意两个事件$A$和$B$，有如下定理：$$P(A\cup B)=P(A)+P(B)-P(A\cap B)$$
    证明：
    事件$A\cup B$由下面三个事件组成：$$A\cup B=(A\setminus B)\cup (A\cap B)\cup (B\setminus A)$$
    首先根据定理 4 有：$${\begin{array}{lcr}P(A\setminus B)&=&P(A)-P(A\cap B)\\P(B\setminus A)&=&P(B)-P(A\cap B)\end{array}}$$
    再根据定理 3 得：$${\begin{aligned}P(A\cup B)&=P(A\setminus B)+P(A\cap B)+P(B\setminus A)\\&=P(A)-P(A\cap B)+P(A\cap B)+P(B)-P(A\cap B)\\&=P(A)+P(B)-P(A\cap B)\end{aligned}}$$
    例如，在由一共 32 张牌构成的斯卡特扑克牌中随机抽出一张，其或者是"方片"或者是"${\mathcal {A}}$"的概率是多少？
    事件$A$，$B$是或者的关系，且可同时发生，就是说抽出的这张牌即可以是"方片"，又可以是"${\mathcal {A}}$"，$A ∩ B$ ( 既发生 A 又发生B ) 的值是 1 / 32，( 从示意图上也可以看出，即是方片又是${\mathcal {A}}$只有一张，即概率是 1 / 32 )，因此有如下结果：$$P(A\cup B)={\frac {8}{32}}+{\frac {4}{32}}-{\frac {1}{32}}={\frac {11}{32}}$$
    注意到公理 3 是定理 5 的特殊情况，即 $A$，$B$ 不同时发生，相应的 P(A∩B)=0。
    定理 6 (乘法法则)	
    事件$A$，$B$ 同时发生的概率是：$$P(A\cap B)=P(A)\cdot P(B\vert A)=P(B)\cdot P(A\vert B)$$
    公式中的**$P(A|B)$是指在B 条件下A发生的概率**，又称作条件概率。
    定理 7 (无关事件乘法法则)
    两个不相关联的事件 A，B 同时发生的概率是：$$P(A\cap B)=P(A)\cdot P(B)$$. 注意到这个定理实际上是定理 6 (乘法法则) 的特殊情况，如果事件 A，B 没有联系，则有 P(A|B)=P(A)，以及 P(B|A)=P(B)。
    贝叶斯定理
    贝叶斯定理由英国数学家托马斯·贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。按照定理 6 的乘法法则，P(A∩B)=P(A)·P(B|A)=P(B)·P(A|B)，可以立刻导出贝叶斯定理：$$P(A\vert B)={\frac {P(B\vert A)\cdot P(A)}{P(B)}}$$
    例如：一座别墅在过去的 20 年里一共发生过 2 次被盗，别墅的主人有一条狗，狗平均每周晚上叫 3 次，在盗贼入侵时狗叫的概率被估计为 0.9，问题是：在狗叫的时候发生入侵的概率是多少？
    我们假设A事件为狗在晚上叫, B为盗贼入侵，则$P(A)=3/7$，$P(B)=2/(20·365.25)=2/7305$，$P(A|B)=0.9$，按照公式很容易得出结果：$$P(B\vert A)=0.9\cdot {\frac {2}{7305}}\cdot {\frac {7}{3}}=0.0005749486653...$$
    随机变量
    离散型随机变量
      分布列
      期望与方差
  组合数学
    排列组合
      二项式定理
    计数原理
  不等式
    一次不等式
  数学归纳与法合情推理
  线性代数
    行列式
    矩阵
  最优化
  随机过程
  其它
    牛顿迭代法
    一般情况二分法求平方根，牛顿迭代法快速寻找平方根比二分法更快。首先随便猜一个近似值x，然后不断令x等于x和a/x的平均数，迭代次数越多越精确。
    这种算法是不断用$(x,f(x))$的切线来逼近方程$x^2-a=0$的根。根号a实际上就是x^2-a=0的一个正实根，这个函数的导数是2x。也就是说，函数上任一点(x,f(x))处的切线斜率是2x。那么，x-f(x)/(2x)就是一个比x更接近的近似值。代入 f(x)=x^2-a得到x-(x^2-a)/(2x)，也就是(x+a/x)/2。 
    下面是示例代码(非常厉害)[参考1](http://www.matrix67.com/data/InvSqrt.pdf)[参考2](https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E9%80%9F%E7%AE%97%E6%B3%95)

```c
float Q_rsqrt( float number )
 {
     long i;
     float x2, y;
     const float threehalfs = 1.5F;
     x2 = number * 0.5F;
     y   = number;
     i   = * ( long * ) &y;   // evil floating point bit level hacking
     i   = 0x5f3759df - ( i >> 1 ); // what the fuck?
     y   = * ( float * ) &i;
     y   = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
     // y   = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this  can be removed
     #ifndef Q3_VM
     #ifdef __linux__
          assert( !isnan(y) ); // bk010122 - FPE?
     #endif
     #endif
     return y;
 }  
```

    双峰函数
    二项式系数
趣味数学
    小数0.9(其中9无限循环)等于1
    证明:
    $0.\dot{9}=3\times 0.\dot{3}=3\times\frac{1}{3}=1$
画线乘法计算法